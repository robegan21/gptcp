/* 
This program was originally generated by ChatGPT on 3/21/2023
and modified by Rob Egan for performance and correctness.

Compile with:
g++ -O3 -fopenmp gptcp.cpp -o gptcp

This was the question:
write a program in C using openmp that acts like linux cp and uses
multiple threads to read and write the file in parallel

This was the answer:
Here is an example program in C using OpenMP that acts like the "cp"
command in Linux and uses multiple threads to read and write the file
in parallel:
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>

#ifdef _OPENMP

#include <omp.h>

#else

#define omp_get_thread_num() 0
#define omp_get_num_threads() 1
#define omp_get_max_threads() 1
#define omp_in_parallel() 0

void omp_set_num_threads(int i) {}
void omp_set_nested(int i) {}

#endif

#ifndef BUF_SIZE
#define BUF_SIZE (16 * 1024 * 1024) /* Modified from 1kb to 16 mb by Rob */
#endif

int main(int argc, char *argv[]) {
    if (argc != 3) {
        fprintf(stderr, "Usage: %s <source> <destination>\n", argv[0]);
        return 1;
    }

    char *src_path = argv[1];
    char *dst_path = argv[2];

    int src_fd = open(src_path, O_RDONLY);
    if (src_fd == -1) {
        perror("open source");
        return 1;
    }

    struct stat src_stat;
    if (fstat(src_fd, &src_stat) == -1) {
        perror("stat source");
        return 1;
    }

    int dst_fd = open(dst_path, O_WRONLY | O_CREAT | O_TRUNC, src_stat.st_mode);
    if (dst_fd == -1) {
        perror("open destination");
        return 1;
    }

    /* added ftruncate for performance by Rob */
    int ret = ftruncate(dst_fd, src_stat.st_size);
    if (ret != 0) {
        perror("failed to ftruncate");
        return 1;
    }

    /* Fixed loop for each thread to manage a large partition of the file */
    off_t block_size = ( src_stat.st_size + omp_get_num_threads() - 1) / omp_get_num_threads();
    off_t remainder = block_size % BUF_SIZE;
    if (remainder != 0) block_size += BUF_SIZE - remainder; // round up to the nearest 16MB
    int all_good = 0;

    #pragma omp parallel reduction(+:all_good)
    {
        int tid = omp_get_thread_num();
        int is_good = 1;
        char *buf = (char*) malloc(BUF_SIZE);
        if (!buf) {
            fprintf(stderr, "Error: thread %d could not allocate %d bytes for buffer\n", tid, BUF_SIZE);
            is_good = 0;
        }
        off_t start = block_size * tid;
        if (start > src_stat.st_size) start = src_stat.st_size;
        off_t offset = start;
        off_t stop = offset + block_size;
        if (stop > src_stat.st_size) stop = src_stat.st_size;
        while (is_good == 1 && stop > offset) {
            off_t read_size = stop - offset;
            if (read_size > BUF_SIZE) read_size = BUF_SIZE;
            ssize_t bytes_read = pread(src_fd, buf, read_size, offset);
            if (bytes_read == 0) break;
            ssize_t bytes_written = pwrite(dst_fd, buf, bytes_read, offset);
            if (bytes_written != bytes_read) {
                fprintf(stderr, "Error: could not write all bytes in thread %d\n", tid);
                is_good = 0;
                break;
            }
            offset += bytes_read;
        }
        if (offset != stop) { /* fixed detection of incomplete copy */
            fprintf(stderr, "Error: thread %d did not write the entire file offset=%ld != stop=%ld\n", tid, offset, stop);
            is_good = 0;
        }
        all_good += is_good;
    }

    close(src_fd);
    close(dst_fd);

    return all_good == omp_get_num_threads() ? 0 : 1; /* Fixed exit status on failure */
}

/* 
The program takes two command-line arguments: the path to the source
file and the path to the destination file. It opens the source file
and reads its metadata using the fstat function. Then it creates the
destination file with the same permissions as the source file using
the open function with the O_WRONLY, O_CREAT, and O_TRUNC flags. It
then reads from the source file in parallel using OpenMP, using the
pread and pwrite functions to read and write chunks of data. Finally,
it closes both file descriptors.

Note that this program assumes that the source file is not being
modified while it is being copied, and it does not preserve ownership,
permissions, or timestamps of the source file.
*/
